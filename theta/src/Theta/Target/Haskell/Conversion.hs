{-# LANGUAGE AllowAmbiguousTypes   #-}
{-# LANGUAGE BangPatterns          #-}
{-# LANGUAGE DefaultSignatures     #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE MultiWayIf            #-}
{-# LANGUAGE NamedFieldPuns        #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TypeApplications      #-}

-- | This module defines classes for converting between Haskell types
-- and Theta values.
--
-- The types generated by Template Haskell have instances of these
-- classes, letting us convert from those types to other formats
-- supported by Theta (like Avro).
module Theta.Target.Haskell.Conversion where

import           Control.Monad                 (replicateM, when)
import           Control.Monad.Except          (MonadError)
import           Control.Monad.State           (MonadState, evalStateT, get,
                                                modify)

import qualified Data.Avro                     as Avro
import qualified Data.Avro.Encoding.ToAvro     as ToAvro
import           Data.Avro.Internal.DecodeRaw  (DecodeRaw)
import qualified Data.Avro.Internal.DecodeRaw  as DecodeRaw
import qualified Data.Avro.Internal.EncodeRaw  as EncodeRaw
import qualified Data.Avro.Internal.Get        as Avro

import           Data.Binary.Get               (Get, runGetOrFail)
import qualified Data.ByteString.Builder       as ByteString
import           Data.ByteString.Lazy          (ByteString)
import qualified Data.ByteString.Lazy          as LBS
import           Data.HashMap.Strict           (HashMap)
import qualified Data.HashMap.Strict           as HashMap
import           Data.Int                      (Int32, Int64)
import           Data.Text                     (Text)
import qualified Data.Text                     as Text
import           Data.Time.Calendar            (Day)
import           Data.Time.Clock               (UTCTime)
import qualified Data.Vector                   as Vector
import           Data.Word                     (Word64)

import           GHC.Stack                     (HasCallStack)

import qualified Theta.Error                   as Theta
import           Theta.Pretty                  (p)
import qualified Theta.Pretty                  as Theta
import           Theta.Types                   (prettyType)
import qualified Theta.Types                   as Theta
import qualified Theta.Value                   as Theta

import qualified Theta.Target.Avro.Values      as Values

import           Theta.Target.Haskell.HasTheta (HasTheta)
import qualified Theta.Target.Haskell.HasTheta as HasTheta

-- * Conversion classes

-- | Types that can be converted /to/ a Theta value based on the
-- schema in its 'HasTheta' instance.
class HasTheta a => ToTheta a where
  toTheta :: a -> Theta.Value

  -- | Convert a Haskell value directly to an Avro-encoded
  -- bytestring. This is significantly more efficient than going
  -- through `toTheta` because it avoids building an intermediate
  -- representation of the data.
  --
  -- Semantically, the following should always hold:
  --
  -- @
  -- avroEncoding = encodeAvro ∘ toAvro ∘ toTheta
  -- @
  avroEncoding :: a -> ByteString.Builder

-- | Types that can be converted /from/ a Theta value that matches the
-- type's schema (in its 'HasTheta' instance).
class HasTheta a => FromTheta a where

  -- | Convert a 'Theta.Value' to a Haskell type, explicitly managing
  -- the error 'Context' with 'MoandState'. If you want to convert a
  -- type from the top (ie with no context), use 'fromTheta' instead.
  --
  -- Raises an error if the Theta value does not have the type
  -- expected based on the target type's 'HasTheta' instance.
  fromTheta' :: (MonadError Theta.Error m, MonadState Context m)
             => Theta.Value
             -> m a

  -- | Convert an Avro-encoded bytestring directly into a Haskell
  -- value. This is significantly more efficient than going through
  -- `toTheta` since it avoids constructing a large intermediate
  -- representation.
  --
  -- Semantically, the following should always hold:
  --
  -- @
  -- avroDecoding = fromTheta ∘ fromAvro ∘ decodeAvro
  -- @
  avroDecoding :: Get a
  default avroDecoding :: DecodeRaw a => Get a
  avroDecoding = DecodeRaw.decodeRaw

-- | Converts a 'Theta.Value' to a Haskell type.
--
-- Raises an error if the Theta value does not have the type expected
-- based on the target type's 'HasTheta' instance.
fromTheta :: (FromTheta a, MonadError Theta.Error m)
          => Theta.Value
          -> m a
fromTheta value = evalStateT (fromTheta' value) []

-- | Convert a Haskell type directly to an Avro-formatted bytestring.
encodeAvro :: ToTheta a => a -> ByteString
encodeAvro value = ByteString.toLazyByteString $ avroEncoding value

-- | Convert an Avro-formatted bytestring directly to a Haskell
-- type. Currently throws exceptions on decoding errors.
decodeAvro :: forall m a. (MonadError Theta.Error m, FromTheta a)
           => ByteString
           -> m a
decodeAvro input = case runGetOrFail avroDecoding input of
  Left (_, _, message) ->
    Theta.throw "Haskell" $ BinaryError (HasTheta.theta @a) $ Text.pack message

  Right (remainder, _, result)
    | LBS.length remainder == 0 -> pure $! result
    | otherwise                 ->
      Theta.throw "Haskell" $ LeftOver (HasTheta.theta @a) remainder
{-# SPECIALIZE decodeAvro :: FromTheta a => ByteString -> Either Theta.Error a #-}

-- * Instances for primitive types

instance ToTheta Bool where
  toTheta = Theta.boolean

  avroEncoding = ToAvro.toAvro Avro.Boolean

instance FromTheta Bool where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Boolean b -> pure b
    _               -> mismatch Theta.bool' type_

  avroDecoding = Avro.getBoolean

instance ToTheta ByteString where
  toTheta = Theta.bytes

  avroEncoding = ToAvro.toAvro (Avro.Bytes Nothing)

instance FromTheta ByteString where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Bytes b -> pure b
    _             -> mismatch Theta.bytes' type_

  avroDecoding = Avro.getBytesLazy

instance ToTheta Int32 where
  toTheta = Theta.int

  avroEncoding = EncodeRaw.encodeRaw

instance FromTheta Int32 where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Int i -> pure i
    _           -> mismatch Theta.int' type_

instance ToTheta Int64 where
  toTheta = Theta.long

  avroEncoding = EncodeRaw.encodeRaw

instance FromTheta Int64 where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Long l -> pure l
    _            -> mismatch Theta.long' type_

instance ToTheta Float where
  toTheta = Theta.float

  avroEncoding = ToAvro.toAvro Avro.Float

instance FromTheta Float where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Float f -> pure f
    _             -> mismatch Theta.float' type_

  avroDecoding = Avro.getFloat

instance ToTheta Double where
  toTheta = Theta.double

  avroEncoding = ToAvro.toAvro Avro.Double

instance FromTheta Double where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Double d -> pure d
    _              -> mismatch Theta.double' type_

  avroDecoding = Avro.getDouble

instance ToTheta Text where
  toTheta = Theta.string

  avroEncoding = ToAvro.toAvro (Avro.String Nothing)

instance FromTheta Text where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.String s -> pure s
    _              -> mismatch Theta.string' type_

  avroDecoding = Avro.getString

instance ToTheta Day where
  toTheta = Theta.date

  avroEncoding = EncodeRaw.encodeRaw @Int32 . Values.fromDay

instance FromTheta Day where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Date day -> pure day
    _              -> mismatch Theta.date' type_

  avroDecoding = Values.toDay <$> DecodeRaw.decodeRaw @Int32

instance ToTheta UTCTime where
  toTheta = Theta.datetime

  avroEncoding = EncodeRaw.encodeRaw @Int64 . Values.fromUTCTime

instance FromTheta UTCTime where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Datetime time -> pure time
    _                   -> mismatch Theta.datetime' type_

  avroDecoding = Values.toUTCTime <$> DecodeRaw.decodeRaw @Int64

instance ToTheta a => ToTheta [a] where
  toTheta values = Theta.Value
    { Theta.value   = Theta.Array $ toTheta <$> Vector.fromList values
    , Theta.type_   = Theta.array' (HasTheta.theta @a)
    }

  avroEncoding = \case
    [] -> encode0
    xs -> encodeInt (length xs) <> foldMap avroEncoding xs <> encode0

instance FromTheta a => FromTheta [a] where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Array xs -> withContext type_ $ Vector.toList <$> traverse fromTheta' xs
    _              -> mismatch (Theta.array' items) type_
      where items = HasTheta.theta @a

  avroDecoding = decodeBlocks avroDecoding

instance ToTheta a => ToTheta (HashMap Text a) where
  toTheta values = Theta.Value
    { Theta.value   = Theta.Map $ toTheta <$> values
    , Theta.type_   = Theta.map' (HasTheta.theta @a)
    }

  avroEncoding map
    | HashMap.null map = encode0
    | otherwise        = size <> foldMap encodeKV (HashMap.toList map) <> encode0
    where encodeKV (k, v) = avroEncoding k <> avroEncoding v
          size            = encodeInt $ length map

instance FromTheta a => FromTheta (HashMap Text a) where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Map values -> withContext type_ $ traverse fromTheta' values
    _                -> mismatch (Theta.map' values) type_
      where values = HasTheta.theta @a

  avroDecoding = HashMap.fromList <$> decodeBlocks keyValue
    where keyValue = do
            key   <- Avro.getString
            value <- avroDecoding
            pure (key, value)

instance ToTheta a => ToTheta (Maybe a) where
  toTheta value = Theta.Value
    { Theta.value   = Theta.Optional $ toTheta <$> value
    , Theta.type_   = Theta.optional' (HasTheta.theta @a)
    }

  avroEncoding Nothing  = encodeInt 0
  avroEncoding (Just x) = encodeInt 1 <> avroEncoding x

-- | 'Maybe' values are decoded from Avro as unions of @["null", a]@
-- (for whatever @a@ is).
instance FromTheta a => FromTheta (Maybe a) where
  fromTheta' Theta.Value { Theta.type_, Theta.value } = case value of
    Theta.Optional value -> withContext type_ $ traverse fromTheta' value
    _                    -> mismatch (Theta.optional' value) type_
      where value = HasTheta.theta @a

  avroDecoding = Avro.getLong >>= \case
    0 -> pure Nothing
    1 -> Just <$> avroDecoding
    n -> fail $ "Invalid tag for decoding an Optional value. \
                \Expected 0 or 1 but got " <> show n

-- ** Avro Encoding Helpers

-- | A '0' word used in the Avro binary format as a terminator for
-- arrays and maps.
encode0 :: ByteString.Builder
encode0 = EncodeRaw.encodeRaw (0 :: Word64)
{-# INLINE encode0 #-}

-- | Encode a Haskell 'Int'.
encodeInt :: Int -> ByteString.Builder
encodeInt x = EncodeRaw.encodeRaw x
{-# INLINE encodeInt #-}

-- * Avro Decoding Helpers

-- | Avro encodes arrays and maps as a series of blocks. Each block
-- starts with a count of the elements in the block. A series of
-- blocks is always terminated with an empty block (encoded as a 0).
decodeBlocks :: Get a -> Get [a]
decodeBlocks element = do
  count <- Avro.getLong
  if | count == 0 -> return []

     -- negative counts are followed by the number of *bytes* in the
     -- array block
     | count < 0  -> do
         _bytes <- Avro.getLong
         items  <- replicateM (fromIntegral $ abs count) element'
         rest   <- decodeBlocks element'
         pure $ items <> rest

     | otherwise  -> do
         items <- replicateM (fromIntegral count) element'
         rest  <- decodeBlocks element'
         pure $ items <> rest
  where
    element' = do
      !x <- element
      pure x

-- * Error handling

-- $ Facilities for handling errors when converting to/from Theta
-- values.

-- ** Context

-- $ The context of an error is a stack of Theta types that we
-- traversed before encountering an error. This helps the user find
-- exactly where a type mismatch occurred.

-- | The context of an error. This should include all the Theta types
-- in which the error is nested, giving the user a way to track down
-- where the error actually occurred.
type Context = [Theta.Type]

-- | Use this function to build the type context as you recurse down
-- types (records, variants, containers... etc).
--
-- @withContext type_@ pushes @type_@ on the context, recurses and
-- then pops the type back off the context.
withContext :: MonadState Context m => Theta.Type -> m a -> m a
withContext type_ recurse = push *> recurse <* pop
  where push = modify (type_ :)
        pop  = modify (drop 1)

-- | Raises a type mismatch error. The error will include the current
-- 'Context' to help localize the problem.
mismatch :: (MonadError Theta.Error m, MonadState Context m)
         => Theta.Type
            -- ^ The expected type.
         -> Theta.Type
            -- ^ The actual type provided.
         -> m a
mismatch expected got = do
  context <- get
  Theta.throw "Haskell" $ TypeMismatch expected got context

-- | Throws an error if the schema of the given value does not match
-- the schema expected by the specified type.
--
-- This function can be used in a monadic context the same way as
-- 'guard':
--
-- @
-- do value <- {- … -}
--    checkSchema @SomeType value
--    {- continue using value -}
-- @
checkSchema :: forall m a.( MonadError Theta.Error m
                          , MonadState Context m
                          , HasTheta a
                          , HasCallStack
                          )
            => Theta.Value
            -> m ()
checkSchema Theta.Value { Theta.type_ } =
  when (HasTheta.theta @a /= type_) $ mismatch (HasTheta.theta @a) type_

-- | Errors that can come up when converting between Haskell types and
-- Theta values.
data ConversionError =
    --             expected     got       context
    --                ↓          ↓           ↓
    TypeMismatch Theta.Type Theta.Type [Theta.Type]
    -- ^ The 'Theta.Value' did not have the type expected by the Haskell
    -- type being generated.
    --
    -- The list of types provides a stack trace of sorts through the
    -- entire Theta schema.

    --            expected  message (from Got)
    --               ↓         ↓
  | BinaryError Theta.Type   Text
    -- ^ We ran into an error decoding a binary Avro representation of
    -- a Theta value. This error includes the type we were expecting
    -- to decode and the error message returned from the binary
    -- parsing code.

    --        expected  unconsumed
    --           ↓          ↓
  | LeftOver Theta.Type ByteString
    -- ^ We parsed a value of the given schema correctly, but the
    -- input had unconsumed bytes left over.
  deriving (Show)

instance Theta.Pretty ConversionError where
  pretty (TypeMismatch expected got context) =
    [p|
       Type mismatch.

       Expected: ‘#{prettyType expected}’
       But got:  ‘#{prettyType got}’
         #{renderedContext}
      |]
      where renderedContext :: Text
            renderedContext = case context of
              []      -> ""
              context ->
                "\nin:\n" <> Text.intercalate "\n" (("↳ " <>) . prettyType <$> context)

  pretty (BinaryError type_ message) =
    [p|
       Error parsing ‘#{prettyType type_}’ from a binary Avro input:

       #{message}
      |]

  pretty (LeftOver type_ remainder) =
    [p|
       Error parsing ‘#{prettyType type_}’ from a binary Avro input:

       #{LBS.length remainder} bytes of the input remains unconsumed.
      |]
